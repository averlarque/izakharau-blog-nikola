<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ilya Zakharau's Blog (Posts about API)</title><link>https://izakharau.me/</link><description></description><atom:link href="https://izakharau.me/categories/cat_api.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2023 &lt;a href="mailto:ilya.zakharau@gmail.com"&gt;Ilya Zakharau&lt;/a&gt; 
&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"&gt;
&lt;img alt="Creative Commons License BY-NC-SA"
style="border-width:0; margin-bottom:12px;"
src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"&gt;&lt;/a&gt;</copyright><lastBuildDate>Tue, 14 Feb 2023 21:44:22 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Definition of API Requirements v2</title><link>https://izakharau.me/posts/definition-of-api-requirements-v2/</link><dc:creator>Ilya Zakharau</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img src="https://izakharau.me/images/api-image.jpeg" alt="API"&gt;&lt;/p&gt;
&lt;p&gt;Requirements definition for APIs is not a standard part of the Business Analysis activities in software development. Usually, API design was a single responsibility of a system architect or a developer, considering implementation subject matter experts.&lt;/p&gt;
&lt;p&gt;During my BA career, I had to deal with API-specific requirements. I realized that the API layer has stakeholders (aka consumers) who have their needs related to APIs provided by a system-of-interest. And those needs should be analyzed and translated into requirements.&lt;/p&gt;
&lt;p&gt;The goal of this essay is to give an introduction to the definition of API requirements for my fellow Business Analysts, Product Owner, and Product Managers.&lt;/p&gt;&lt;p&gt;&lt;a href="https://izakharau.me/posts/definition-of-api-requirements-v2/"&gt;Read more…&lt;/a&gt; (8 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>API Design</category><guid>https://izakharau.me/posts/definition-of-api-requirements-v2/</guid><pubDate>Tue, 14 Feb 2023 21:07:00 GMT</pubDate></item><item><title>API Design Tooling</title><link>https://izakharau.me/posts/api-design-tooling/</link><dc:creator>Ilya Zakharau</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img src="https://izakharau.me/images/api-design-tooling/back.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;This article is a part of the &lt;a href="https://izakharau.me/pages/api-design"&gt;API Design&lt;/a&gt; series, where I will review several API design tools and summarize my experiences. There are the following criteria I use in selecting and evaluating the tools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it is free: either open source or a free plan of a paid product&lt;/li&gt;
&lt;li&gt;out-of-the-box functionality is considered only: no plugins&lt;/li&gt;
&lt;li&gt;both web and desktop products are considered&lt;/li&gt;
&lt;li&gt;it allows designing REST API definition in OpenAPI 3.x with JSON/YAML (low-code), UI means (no-code), or a combination of both&lt;/li&gt;
&lt;li&gt;code generation functionality is not required as there are several 3rd party libraries to do that&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I am not promoting, just expressing my honest opinion.&lt;/p&gt;&lt;p&gt;&lt;a href="https://izakharau.me/posts/api-design-tooling/"&gt;Read more…&lt;/a&gt; (10 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>API Design</category><guid>https://izakharau.me/posts/api-design-tooling/</guid><pubDate>Tue, 27 Dec 2022 22:15:30 GMT</pubDate></item><item><title>API Design-First</title><link>https://izakharau.me/posts/api-design-first/</link><dc:creator>Ilya Zakharau</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img src="https://izakharau.me/images/api-design-first-back.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;This article is a part of the &lt;a href="https://izakharau.me/pages/api-design"&gt;API Design&lt;/a&gt; series, where I will uncover API design concepts for my non-technical peers. You don't need to be a developer or an architect to participate to design or even build an API, but there is something you should learn to succeed.&lt;/p&gt;
&lt;p&gt;So we start with API design-first, which takes the opportunity to democratize the API development process.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://izakharau.me/posts/api-design-first/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>API Design</category><guid>https://izakharau.me/posts/api-design-first/</guid><pubDate>Mon, 26 Dec 2022 22:35:30 GMT</pubDate></item><item><title>“Backward awkwardability” or how to break compatibility and stop worrying</title><link>https://izakharau.me/posts/backward-compatibility/</link><dc:creator>Ilya Zakharau</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img src="https://izakharau.me/images/breaking_changes.jpeg" width="90%" alt="Breaking changes everywhere" style="vertical-align:middle;margin:1% 1%"&gt;&lt;br&gt;
When you are responsible for services widely used by other teams inside and partners outside, you most likely become paranoid about maintaining backward compatibility of your API as much as possible. I had no idea about what backward compatibility means in terms of software engineering until I started working on microservices. Those microservices were important for the organization’s success. And in the same time that was a highly volatile environment with rapidly growing functionality and direction changes on the fly.&lt;/p&gt;
&lt;p&gt;Back then, I invented the term “backward awkwardability”: when you feel awkward while telling your customers that an upcoming release is not compatible with a previous so they have some work to do. They say something like: “C’mon guys, you introduced breaking changes just a few iterations before! What’s going on?” Ugh, each time I feel sick just remembering those situations.&lt;/p&gt;
&lt;p&gt;So we are going to talk about the nature of backward compatibility and how to deal with the breaking changes in terms of API.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://izakharau.me/posts/backward-compatibility/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://izakharau.me/posts/backward-compatibility/</guid><pubDate>Mon, 26 Apr 2021 13:30:00 GMT</pubDate></item><item><title>Definition of API requirements</title><link>https://izakharau.me/posts/definition-of-api-requirements/</link><dc:creator>Ilya Zakharau</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;img src="https://izakharau.me/images/api.jpg" width="90%" alt="API" style="vertical-align:middle;margin:1% 1%"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There is a &lt;a href="https://izakharau.me/posts/definition-of-api-requirements-v2"&gt;2nd revision of this article&lt;/a&gt;, so please read it instead. This, as my first published post in this blog, will stay here as a reminder of my bad writing.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;At some point in my career, I faced a need to specify requirements for API. Those were not typical solution requirements I worked on before. I learned about the API layer which is very common among the enterprise systems. It can hide a set of microservices or a legacy system from the outer world. Like any other system, it is also impacted by stakeholders' needs. And those needs have to be translated into requirements.&lt;/p&gt;
&lt;p&gt;We are going to decompose the definition of API requirements and see what lies within. I will pay your attention to what should be taken into consideration for the API layer. It is an introduction to this topic as there are other sides of it to explore further.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://izakharau.me/posts/definition-of-api-requirements/"&gt;Read more…&lt;/a&gt; (10 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><guid>https://izakharau.me/posts/definition-of-api-requirements/</guid><pubDate>Tue, 30 Mar 2021 06:00:00 GMT</pubDate></item></channel></rss>